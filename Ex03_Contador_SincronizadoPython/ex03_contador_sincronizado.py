# -*- coding: utf-8 -*-
"""Ex03_Contador_Sincronizado.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a9w54HBYukv6r2_t_zFX3BaiYV-N5tbx
"""

from threading import Thread, Lock  # Importa as classes Thread e Lock do módulo threading

class ContadorSincronizado:
    def __init__(self):
        self.contador = 0  # Inicializa o contador em 0
        self.lock = Lock()  # Cria um Lock para sincronização entre threads

    # Método sincronizado para incrementar o contador
    def incrementar(self):
        with self.lock:  # Garante que apenas uma thread possa acessar este bloco por vez
            self.contador += 1  # Incrementa o contador

    # Método para obter o valor final do contador
    def get_contador(self):
        return self.contador  # Retorna o valor atual do contador

# Função para a primeira thread que incrementa o contador 100 vezes
def incrementar_contador_1(contador_sincronizado):
    for i in range(100):
        contador_sincronizado.incrementar()  # Chama o método para incrementar o contador
        print(f"Thread 1: Iteração {i}, Contador = {contador_sincronizado.get_contador()}")  # Imprime o índice da iteração e o valor do contador

# Função para a segunda thread que incrementa o contador 100 vezes
def incrementar_contador_2(contador_sincronizado):
    for i in range(100):
        contador_sincronizado.incrementar()  # Chama o método para incrementar o contador
        print(f"Thread 2: Iteração {i}, Contador = {contador_sincronizado.get_contador()}")  # Imprime o índice da iteração e o valor do contador

def main():
    contador_sincronizado = ContadorSincronizado()  # Cria uma instância da classe ContadorSincronizado

    # Criação da primeira thread que usa a função definida
    thread1 = Thread(target=lambda: incrementar_contador_1(contador_sincronizado))

    # Criação da segunda thread que usa a função definida
    thread2 = Thread(target=lambda: incrementar_contador_2(contador_sincronizado))

    # Inicia as threads
    thread1.start()  # Inicia a execução da primeira thread
    thread2.start()  # Inicia a execução da segunda thread

    # Aguarda ambas as threads terminarem
    thread1.join()  # Bloqueia a execução até que thread1 termine
    thread2.join()  # Bloqueia a execução até que thread2 termine

    # Imprime o valor final do contador
    print("Valor final do contador:", contador_sincronizado.get_contador())  # Deve ser 200

if __name__ == "__main__":
    main()  # Chama a função main se o script for executado diretamente